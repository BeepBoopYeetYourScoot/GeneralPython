# Функция - набор инструкций, выполняющих определённое действие
# В инструкциях по чистому коду говорится, что функция должна выполнять только одно конкретное
# действие. Именование функций должно быть в виде глаголов, потому что они что-то делают
# Нет ничего зазорного в том, чтобы делить свой код на более мелкие функции, потому что
# впоследствии, объединив имеющиеся функции, можно сформировать классы с уже известными методами.

# Чтобы намечать нужные функции, не расписывая их полностью, можно использовать pass. В таком случае,
# программа не будет выдавать ошибку о том, что поля функции не заполнены


def greet():
    pass


# Чтобы вызвать функцию, обязательно использовать скобки после её названия. В противном случае
# будет выбрана сама функция как объект, а не то, что она делает
# С точки зрения принципов проектирования, функции позволяют реализовать принцип DRY - они позволяют
# переиспользовать уже имеющийся код.

# Функции могут не только выполнять какие-то действия, но и возвращать какие-либо значения
# при их вызове.
# Данный метод всегда выполняется в конце функции и его можно использовать в качестве безопасной проверки правильности
# работы кода.

def new_greet():
    return 'Hello Function!'


print(new_greet())

# Возвращаемые функциями значения (если использован return) представляют собой тот тип данных, который они возвращают
# Это позволяет комбинировать свои функции с методами, присущими для конкретных типов данных

print(new_greet().upper())

# Функции могут принимать на вход значения. Дядя Боб говорит, что функция должна содержать не более 3х
# входных аргументов. При объявлении функции, которая принимает на вход какие-либо данные, функциональные переменные
# являются локальными, т.е. они не будут доступны вне данной функции


def make_greet(greeting):
    return f'{greeting} Function'


print(make_greet('Privet'))

# В случаях, когда в функции имеются два параметра, но один из них необязателен, можно устанавливать стандартные
# значения данных параметров. Обязательные параметры всегда должны располагаться раньше опциональных (keyword args)


def greet_you(greeting, name='to you'):
    return f'{greeting}, {name}'


print(greet_you('Henlo'))

# Рассмотрим аргументы типа *args, **kwargs. Имеются случаи, когда мы знаем, что должна делать функция, но нам не
# обязательно знать её входные аргументы. Тогда применяются данные методы. Обязательные аргументы организуются в виде
# кортежа, опциональные - в виде словаря {'ключ': значение}.


def calculate(*args, **kwargs):
    return f'Обязательные аргументы:\n{args}\nОпциональные аргументы:\n{kwargs}'


print(calculate('abc', 'def', 'ghi', leto='osen', papirosim='papirosim', number=228))

# Имея представление о том, каким образом представляются обязательные (*args) и опциональные (**kwargs),
# можно по аналогии продолжить и сказать, как можно передать несколько уже существующих аргументов прямо в функцию.
#


def get_student_info(*args, **kwargs):
    for course in args:
        print(f'Student attends {course} class')

    for info in kwargs:
        print(f'Student filled {info} about himself.')


courses = ['Math', 'Art', 'English']
student_info = {
    'name': 'John',
    'age': 22,
    'specialization': 'Computer Science',
    'is_student': True
}

get_student_info(*courses, **student_info)
