# Посмотрим на то, каким образом устроены файловые объекты в Питоне
# При работе мы будем постоянно работать с файлами, поэтому необходимо знать, что с ними
# можно делать

# Файлы можно открывать двумя способами:

# 1. Использовать пару функций open - close. Открывая файл таким образом, мы должны открыто
# написать функцию закрытия. Если этого не сделать, могут произойти утечки, которые приведут
# к превышению количества файловых дескрипторов в системе и приложения могут выдавать ошибку.

# 2. Использовать менеджер контекста. В большинстве случаев, нужно будет пользоваться именно
# этим способом. Для такого подхода используется ключевое слово 'with':

with open('test.txt', 'r') as enter_the_file:
    pass

# При выходе из данного блока файл закроется автоматически - даже в случаях, когда во время
# исполнения происходят исключения. Это одна из практик для написания хорошего (и чистого
# кода).

with open('test.txt', 'r') as f:
    f_contents = f.read()
    print(f_contents)

# Данные файла можно считывать как список, где каждое значение представляет собой отдельную
# строку файла

with open('test.txt', 'r') as f:
    f_contents = f.readlines()
    print(f_contents)

# Методы readline и readlines не подходят для работы с большими файлами. Для этого можно
# использовать цикл. Такой метод позволяет не засорять память, потому что цикл проходит по
# одной строчке за раз, а не обрабатывает весь файл сразу

# with open('test.txt', 'r') as f:
#     for line in f:
#         print(line, end='')

# Бывают случаи, когда нужно лучше контролировать то, что считывается с файла

# with open('test.txt', 'r') as f:
#
#     f_contents = f.read(100)  # Позволяет считать первые 100 символов файла
#     print(f_contents, end='')
#
#     # По достижении конца файла, метод будет возвращать пустую строку

with open('test.txt', 'r') as f:
    size_to_read = 10
    f_contents = f.read(size_to_read)

    print(f.tell())  # Данный метод показывает позицию символа, на котором остановился метод
    # read

    f.seek(0)  # Данный метод позволяет вернуть метод read к указанной позиции

    # while len(f_contents) > 0:
    #     print(f_contents, end='')
    #     f_contents = f.read(size_to_read)



